Урок 22:
NavLink to в Dialogs - делает ссылки для компоненты Route
Важно импортировать компоненту NavLink из 'react-router-dom'
exact внутри Route позволяет сделать переход по ссылке только если адрес точный

Урок 23:
Разбиваем на компоненты Dialogs
Делаем красивее верстку в Profile
props name, props id добавляем

Урок 24:
Добавлен массив данных в Dialogs и интегрирован в эту компаненту через props

Урок 25. Метод map()
Есть массив данных:
let dialogsData = [
        { id: 6, name: 'Alberth' },
        { id: 7, name: 'Victoria' },
        { id: 8, name: 'Romualda' },
        { id: 9, name: 'Germiona' },
        { id: 10, name: 'Antoniy' },
    ]

    let messagesData = [
        { id: 4, text: 'You' },
        { id: 5, text: 'Kick' },
        { id: 6, text: 'My name is Barry' },
        { id: 7, text: 'JavaScript is my favorite language.' },
        { id: 8, text: "Swift is my wife's favorite language." },
    ]
С помощью метода map вставляем эти данные в другой массив, возвращающий компаненту(ты)
Примеры с одним аргументов и одним элементом вывода
let dialogsElements = dialogsData.map(dialog => <Dialog name={dialog.name} id={dialog.id} />)
let messagesElements = messagesData.map(message => <Message text={message.text} />)
В примере с несколькими аргументами, нужны будут скобки () и слово return в теле функции. Больше можно узнать в гугле

А таким образом вставляется результат в JSX файле
{dialogsData}

Урок 26-29:
Перенос массивов данных с помощью props в index.js

Урок 30: обобщение теории

Урок 31:
Добавлен в Profile и Dialogs onClick() в button, ref в texterea, React.createRef и peremennaya.сurrent.calue
Это нужно было сделать для того, чтобы при нажатии на кнопку вызывалась функция, которую мы потом заменим на добавление введенных данных в базу
 и потом сделаем чтобы из базы создавался пост или отплавлялось сообщение.

Урок 32:
Добавлена функция addUser в state и передана через props в компаненту Dialogs, заменив на её alert()

Урок 33: Основы Flux-концепции
Добавление функции rerenderEntireTree() в render.js(файл создан чтобы не было функционального зацикливания. Не замыкались import и export)
Функция rerenderEntireTree(); перересовывает всё дерево UI (это не эффективно, но для обучения пойдет) при изменениях в данных в state

Урок 34. Flux-концепция. Flux-круговорот на каждый сивол в texterea
34.1 Исправлена ОШИБКА в передаче функций и данных из state.js. Сделал через props. a были ипортированы в нижние модули.
34.2 Flux-круговорот на каждый сивол в texterea. Без передачи данных в другой модуиль не получилось. 
Но по flux-концепции обязательно данные передавать в state.js. Это особенно важно для больших проектов, 
которые нужно будет поддерживать.

Урок 35. 
Удалил файл render.js т.к. он не решал проблемы import-цикличности.
Проблема решана с помощью callback-функции и паттерна проектирования observer

Урок 36-37. 
Создание объекта store (собрать всё в стэйт). Пеедача через пропсы с методом bind.

Урок 38: 
Объединение всех функций в store одной функцией dispatch с арументами в объекте action 
(Чтобы понять принципы работы Redux) 

Урок 39:
Создание функций ActionCreator и переменных для передачи нужных значений в объект action в React-компонентах. 
функции ипортируются в React. А в Redux остаётся работать только со значением переменных и они автоматически подстроятся. 
В итоге не нужно искать по всему коду. И легче не ошибиться.

Урок 40. (обобщение)

Урок 41. 
Создание reducer и перенос функций из state в него. 
Reducer это чистая функция, принимаются state и action и возвращающая измененный state

Урок 42.
Файл stete.js переименова на store.js.
Установлена библиотера redux с помощью команды npm install redux --save
Создан новый файл redux-store.js. В нем с помощью библиотеки Redux можно создать объект store на подобие того,
какой был создан нами ранее ручками.

Урок 43.
Добавление контейнерных компанент.
Презентационная компанента должны быть чистой в идеале и только возвращать HTML-код
Задача контейнерной компаненты - предоставить данные из store для презентационной, чтобы ей осталось только отрисовать.

Урок 44. Контекст (Context API)
Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.
В контекст допустимо помещать глоальные переменный (например цвет темы, язык и т.п.)
Можно подробнее почитать на сайте React на русском. 
const MyContext = React.createContext(defaulValue)
<MyContext.Provider value={store}> - Обрамляем в index.js 
<MyContext.Consumer> - обрамляем чтобы вызвать в дочерней компоненте

Урок 45. Установка react-redux
npm install react-redux --save
Provider. в дочерней компоненте, вызывается функция connect(f1,f2)(child_component);
f1 - функция, возвращающая данные из state, f2 - функция, возвращающая методы из dispatch. 'Это примерное описание'

Урок 46 правильное копирование объектов
Объекты и принимитивы в файле index_demo.html

Урок 47
Так как в функции connect есть операция по перересовке конкретной компоненты, то мы удалили из index.js функцию rerender по переотрисове всего дерева.
Скопировал state внутри функций в dialogs-reducer и в profile-reducer. Т.к. connect не перересовывает из-за этого. 
Ей нужен новый оббъект. старый менять нельзя. а менялся старый.

Урок 48.
Рефакторинг reducer(ов). В каждом case в return добавили сразу копию state c нужными изменениями. 
Делал это придерживаясь концепции чистых функций, чтобы не было переменных за пределами цикла switch.
Также в компонентах My_posts и Dialogs в методе map добавлен key={агрумент.id} чтобы убрать из консоли ошибки 'key'

Урок 49